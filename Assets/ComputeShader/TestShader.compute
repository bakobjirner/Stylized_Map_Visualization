// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

float Resolution;
float Thickness;
float NumberOfPoints;
float4 Bounds;
float4 Color;

RWStructuredBuffer<float2> points;


/**
/calculates the distance of point p to the line between start and end
**/
float distanceToLine(float2 start, float2 end, float2 p) {

    //first calculate distances of points
    float a = distance(start, end);
    float b = distance(start, p);
    float c = distance(p, end);

    //calculate area of triangle according to heron
    float area = 0.25 * sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));

    //calculate heigth of triangle 
    float height = area * 2 / a;

    //return height of triangle since it is the distance
    return height;
}

bool checkOnLine(float2 p1, float2 p2, float2 p) {
    float minX;
    float maxX;
    float minY;
    float maxY;

    //if close to points, return to reduce computing time
    if (distance(p1,p) < Thickness) {
        return true;
    }

    if (p1.x > p2.x) {
        minX = p2.x;
        maxX = p1.x;
    }
    else {
        minX = p1.x;
        maxX = p2.x;
    }
    if (p1.y > p2.y) {
        minY = p2.y;
        maxY = p1.y;
    }
    else {
        minY = p1.y;
        maxY = p2.y;
    }
    //add thickness to min and max, to allow for proper representation of edge-cases
    if (p.x > minX - Thickness && p.x < maxX + Thickness && p.y > minY - Thickness && p.y < maxY + Thickness) {


        float dst = distanceToLine(p1, p2, p);

        if (dst < Thickness) {
            return true;
        }
    }
    return false;
}

/**
 * Based on an algorithm of https://www.algorithms-and-technologies.com/point_in_polygon
 * Performs the even-odd-rule Algorithm to find out whether a point is in a given polygon.
 * This runs in O(n) where n is the number of edges of the polygon.
 */
bool pointInPolygon(float2 p) {
    //A point is in a polygon if a line from the point to infinity crosses the polygon an odd number of times
    bool odd = false; // Starting with the edge from the last to the first node
    //For each edge (In this case for each point of the polygon and the previous one)
    int j = NumberOfPoints - 1;
    for (int i = 0; i < NumberOfPoints; i++) { 
        //If a line from the point into infinity crosses this edge
        // One point needs to be above, one below our y coordinate
        if (((points[i].y > p.y) != (points[j].y > p.y))
                // ...and the edge doesn't cross our Y corrdinate before our x coordinate (but between our x coordinate and infinity)
            && (p.x < (points[j].x - points[i].x) * (p.y - points[i].y) / (points[j].y - points[i].y) + points[i].x)) {
            // Invert odd
            odd = !odd;
        }
        j = i;
    }
    //If the number of crossings was odd, the point is in the polygon
    return odd;
}

[numthreads(8,8,1)]
void CSMain (int3 id : SV_DispatchThreadID)
{
    float x = (id.x / Resolution - 0.5) * 360;
    float y = (id.y / Resolution - 0.5) * 180;

    //check if in country bounds
    if (x<Bounds.x || x > Bounds.y || y<Bounds.z || y>Bounds.w) {
        return;
    }

    float r = 0;
    float g = 0;
    float b = 0;

    //draw Points
    /*
    for(int i = 0; i< NumberOfPoints; i++){
        //draw points
        float dst = distance(float2(points[i].x, points[i].y), float2(x,y));
        if (dst < Thickness) {
            g = 1;
        }
    }
    */

    //fill polygons
    if (pointInPolygon(float2(x, y))) {
        r = Color.x;
        g = Color.y;
        b = Color.z;
        Result[id.xy] = float4(r, g, b, 0.0);
    }


    //draw lines
    for (int j = 0; j < NumberOfPoints-1; j++) {
    float2 p1 = points[j];
    float2 p2 = points[j+1];
    float2 p = float2(x, y);

    if (checkOnLine(p1, p2, p)) {
        r = 1;
        g = 1;
        b = 1;
        Result[id.xy] = float4(r, g, b, 0.0);
    }
    }
}

