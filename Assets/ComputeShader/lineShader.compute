// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

float Resolution;
float Thickness;
float NumberOfPoints;
float4 Bounds;
float4 Color;

RWStructuredBuffer<float2> points;


/**
/calculates the distance of point p to the line between start and end
**/
float distanceToLine(float2 start, float2 end, float2 p) {

    //first calculate distances of points
    float a = distance(start, end);
    float b = distance(start, p);
    float c = distance(p, end);

    //calculate area of triangle according to heron
    float area = 0.25 * sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));

    //calculate heigth of triangle 
    float height = area * 2 / a;

    //return height of triangle since it is the distance
    return height;
}

bool checkOnLine(float2 p1, float2 p2, float2 p) {
    float minX;
    float maxX;
    float minY;
    float maxY;

    //if close to points, return to reduce computing time
    if (distance(p1,p) < Thickness) {
        return true;
    }

    if (p1.x > p2.x) {
        minX = p2.x;
        maxX = p1.x;
    }
    else {
        minX = p1.x;
        maxX = p2.x;
    }
    if (p1.y > p2.y) {
        minY = p2.y;
        maxY = p1.y;
    }
    else {
        minY = p1.y;
        maxY = p2.y;
    }
    //add thickness to min and max, to allow for proper representation of edge-cases
    if (p.x > minX - Thickness && p.x < maxX + Thickness && p.y > minY - Thickness && p.y < maxY + Thickness) {


        float dst = distanceToLine(p1, p2, p);

        if (dst < Thickness) {
            return true;
        }
    }
    return false;
}

[numthreads(8,8,1)]
void CSMain (int3 id : SV_DispatchThreadID)
{
    float x = (id.x / Resolution - 0.5) * 360;
    float y = (id.y / Resolution - 0.5) * 180;

    //check if in bounds
    if (x<Bounds.x || x > Bounds.y || y<Bounds.z || y>Bounds.w) {
        return;
    }

    float r = 0;
    float g = 0;
    float b = 0;


    //draw lines
    for (int j = 0; j < NumberOfPoints-1; j++) {
    float2 p1 = points[j];
    float2 p2 = points[j+1];
    float2 p = float2(x, y);

    if (checkOnLine(p1, p2, p)) {
        r = Color.x;
        g = Color.y;
        b = Color.z;
        Result[id.xy] = float4(r, g, b, 0.0);
    }
    }
}

